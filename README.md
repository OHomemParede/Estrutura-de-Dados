# README
Este programa tem como objetivo calcular o tempo que as funções de ordenação levam para ordenar listas de 10000, 20000 e 30000 elementos em sua composição.

Funções de Ordenação Utilizadas

| ## Seleção<br><br>Realiza a ordenação de uma lista da Esquerda para a Direita, ou seja, pego o elemento da posição atual **A**  e comparo com o elemento seguinte **B**, caso:<br><br>**A < B** (**A** for menor que **B**) -> **A** continua na mesma posição e eu comparo o elemento **B** com o próximo da lista<br>**B < A** (**B** for menor que **A**) -> **B** troca de posição com **A** e eu comparo com o próximo da lista<br><br>!\[Simulação Seleção\](caminho até a imagem)                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ## Inserção<br><br>Realiza a ordenação de uma lista olhando apenas para a Direita, fazendo comparações de elemento por elemento.<br><br>**A** compara com **B**<br>**A** compara com **C**<br>**A** compara com **D**<br>**.**<br>**.**<br>**.**<br><br>!\[Simulação Inserção\](caminho até a imagem)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ## MergeSort (misturar e Intercalar)<br><br>Realiza a ordenação de uma lista **A** utilizando um vetor auxiliar **B**, divide a lista em dois e ordena cada pedaço de forma individual, no final reune os dados, formando uma lista novamente tudo isso dentro do vetor **B** auxiliar, depois é enviado para o vetor original **A**.<br><br>**# Lista A**<br>**[ 10, 9, 5, 2, 4, 3, 1, 7, 6, 8 ]**<br><br>**# Divisao da lista por 2**<br>**[ 10, 9, 5, 2, 4 ]     [ 3, 1, 7, 6, 8 ]**⤵️<br>**[ 10, 9 ]   [ 5 ]   [ 2, 4 ]    [ 3, 1 ]    [ 7 ]   [ 6, 8 ]**⤵️<br>**\[ 10 \] [ 9 ] \[ 5 \] [ 2 ] \[ 4 \] [ 3 ] \[ 1 \] [ 7 ] \[ 6 \] [ 8 ]**<br><br># **Agrupando elementos por ordem**<br>**[ 9, 10 ]   [ 5 ]   [ 2, 4 ]    [ 1, 3 ]    [ 7 ]   [ 6, 8 ]**⤵️<br>**[ 2, 4, 5, 9, 10 ]    [1, 3, 6, 7, 8 ]**⤵️<br>**[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]**<br><br>!\[Simulação Inserção\](caminho até a imagem) |
| ## QuickSort<br><br>Realiza a ordenação de uma lista com a ajuda de um pivô ou numero de referência para auxiliar na ordenação.<br><br>!\[Simulação Inserção\](caminho até a imagem)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |

Também utiliza dois algoritmos de busca, para calcular quantas buscas são realizadas durante a ordenação das listas.

| ## Busca Binária<br><br>Realiza a busca de um elemento dividindo a lista em pares             |
| --------------------------------------------------------------------------------------------- |
| ## Busca Sequencial<br><br>Realiza a busca de um elemento procurando de elemento por elemento |

As simulações foram realizadas na plataforma \[VisuAlgo\](https://visualgo.net/bn/sorting)

## Biblioteca Time.time()

Return the time in seconds since the [epoch](https://docs.python.org/3/library/time.html#epoch) as a floating point number. The specific date of the epoch and the handling of [leap seconds](https://en.wikipedia.org/wiki/Leap_second) is platform dependent. On Windows and most Unix systems, the epoch is January 1, 1970, 00:00:00 (UTC) and leap seconds are not counted towards the time in seconds since the epoch. This is commonly referred to as [Unix time](https://en.wikipedia.org/wiki/Unix_time). To find out what the epoch is on a given platform, look at `gmtime(0)`.
Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second. While this function normally returns non-decreasing values, it can return a lower value than a previous call if the system clock has been set back between the two calls.
The number returned by `[time()](https://docs.python.org/3/library/time.html#time.time)` may be converted into a more common time format (i.e. year, month, day, hour, etc…) in UTC by passing it to `[gmtime()](https://docs.python.org/3/library/time.html#time.gmtime)` function or in local time by passing it to the `[localtime()](https://docs.python.org/3/library/time.html#time.localtime)` function. In both cases a `[struct_time](https://docs.python.org/3/library/time.html#time.struct_time)` object is returned, from which the components of the calendar date may be accessed as attributes.  


